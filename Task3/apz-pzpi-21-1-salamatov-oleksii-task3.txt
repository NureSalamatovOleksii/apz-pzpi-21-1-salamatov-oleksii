1 ОПИС АРХІТЕКТУРИ IOT ЧАСТИНИ
     
  Для написання IoT складової системи було обрано реалізацію мови програмування Python MicroPython для ESP32. У якості середовища розробки було обрано онлайн-платформу Wokwi.com, тому що вона представляє зручний безкоштовний симулятор смарт-пристроїв із усім необхідним функціоналом.
  Для програмування різних частин мікроконтролера ESP32  були використані написані власноруч бібліотеки sonic_lib.py, oled_lib.py, hx711.py.
  Щоб реалізувати Wi-Fi функціонал було також використано бібліотеки network, urequests, json тощо. 
  Для більш детальної демонстрації використаних пакетів було розроблено діаграму пакетів (див. рис. 2).
  Бібліотека sonic_lib.py надає драйвер для використання ультразвукового сенсора HC-SR04 з мікроконтролерами, які підтримують MicroPython. Сенсор HC-SR04 використовується для вимірювання відстані до об'єкта за допомогою ультразвукових хвиль. Він має діапазон вимірювань від 2 см до 4 м.
  Бібліотека oled_lib.py забезпечує функціонал для роботи з OLED дисплеями SSD1306 через інтерфейси I2C та SPI. Вона дозволяє ініціалізувати дисплей, налаштовувати контрастність, відображати текст, малювати пікселі та інші графічні операції. Клас SSD1306 містить основні функції для керування дисплеєм, а підкласи реалізують специфічні методи для роботи з I2C та SPI інтерфейсами відповідно. Бібліотека налаштовує дисплей, керує буфером кадрів і дозволяє відправляти команди та дані на дисплей для його оновлення.
  Бібліотека hx711.py дозволяє взаємодіяти з аналогово-цифровим перетворювачем HX711, який використовується для зчитування даних з вагових датчиків. Вона забезпечує функції для ініціалізації датчика, зчитування даних, налаштування масштабування та калібрування (обнулення). Бібліотека також підтримує увімкнення та вимкнення живлення датчика.
  Бібліотека network була використана для реалізації Wi-Fi підключення.
  Бібліотеки urequests та json були імпортовані для успішного виконання http-запитів до сервера.
  Програмна частина пристрою складається з кодової частини для мікроконтролера ESP32, основна частина якої знаходиться у файлі main.py, з якого і починається виконання програми. Вже з нього відбувається взаємодія з іншими класами системи, запити до сервера, імпорт бібліотек тощо.
  Тип архітектури, розробленої IoT частини програмної системи, відноситься до периферійних обчислень (Edge Computing), оскільки основна обробка та прийняття рішень виконуються локально на пристрої (ESP32), а сервер використовується для додаткових функцій, таких як віддалений моніторинг та зберігання даних.

2 БУДОВА ПРИСТРОЮ

  Пристрій для IoT частини проєкту складається з мікроконтролера ESP32, ультразвукового датчика відстані HC-SR04, підсилювача тензодатчика HX711 на 50 кг, монохромного OLED-дисплею розміром 128x64 з інтерфейсом I2C, п’єзоелектричного гудка, трьох світлодіодів червоного, жовтого та зеленого кольору, одного RGB діоду та двох кнопок зеленого та червоного кольору відповідно (див. рис. 1).
  Контролер ESP32 є центральним елементом пристрою, який керує всіма компонентами. Ультразвуковий датчик HC-SR04 використовується для вимірювання відстані і має чотири піни: VCC підключений до 3.3V ESP32, GND до GND ESP32, Trig до піну D23 ESP32 для надсилання ультразвукових імпульсів, а Echo до піну D22 ESP32 для приймання відбитих імпульсів.
  Три світлодіоди служать для індикації різних станів пристрою: червоний світлодіод підключений до піну D19 ESP32, жовтий до піну D18 ESP32, а зелений до піну D5 ESP32. Катоди всіх світлодіодів з’єднані з GND через резистори для обмеження струму.
  Зумер підключений до піну D4 ESP32, що дозволяє ESP32 керувати звуковими сигналами, тоді як інший його контакт з’єднаний з GND. OLED дисплей використовується для відображення інформації і має чотири піни: GND підключений до GND ESP32, VCC до 3.3V ESP32, SCL до піну D15 ESP32, а SDA до піну D14 ESP32, що забезпечує зв'язок через I2C інтерфейс.
  Навантажувальний датчик підключений до підсилювача HX711, який дозволяє вимірювати вагу. HX711 має чотири піни для підключення до ESP32: GND до GND ESP32, VCC до 3.3V ESP32, DT до піну D13 ESP32 для передачі даних, а SCK до піну D12 ESP32 для синхронізації.
  Дві кнопки використовуються для керування пристроєм. Зелена кнопка підключена до піну D21 ESP32, а червона кнопка до піну D19 ESP32. Інші контакти обох кнопок з’єднані з GND для завершення електричного кола.
  Отож, так було визначено основні апаратні компоненти IoT частини проєкту.

3 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ
     
  Користувачами IoT частини розробленої системи є 2 типи акторів: адміністратор та клієнт.
  Основними потребами клієнта є: здача сміття, визначення його ваги, отримання повідомлення з інформацією щодо здачі, реєстрація власного профілю для нарахування бонусів, а також перегляд статусу контейнера.
  Основними потребами адміністратора є: можливість налаштування роботи пристрою, відстежування змін, редагування та збір даних, формування запиту на вивіз сміття, моніторинг стану контейнера, отримання повідомлень про помилки та збої в роботі системи.
  Взаємодію кожної ролі користувачів з IoT частиною системи представлено на діаграмі прецедентів (див. додат. А.1). 
  Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою. 

4 ПОБУДОВА ДІАГРАМИ ПАКЕТІВ
     
  Для програмування різних частин мікроконтролера ESP32  були використані написані власноруч бібліотеки sonic_lib.py, oled_lib.py, hx711.py.
  Щоб реалізувати Wi-Fi функціонал було також використано бібліотеки network, urequests, json тощо. 
  Для більш детальної демонстрації використаних пакетів було розроблено діаграму пакетів (див. рис. 2).
  Бібліотека sonic_lib.py надає драйвер для використання ультразвукового сенсора HC-SR04 з мікроконтролерами, які підтримують MicroPython. Сенсор HC-SR04 використовується для вимірювання відстані до об'єкта за допомогою ультразвукових хвиль. Він має діапазон вимірювань від 2 см до 4 м.
  Бібліотека oled_lib.py забезпечує функціонал для роботи з OLED дисплеями SSD1306 через інтерфейси I2C та SPI. Вона дозволяє ініціалізувати дисплей, налаштовувати контрастність, відображати текст, малювати пікселі та інші графічні операції. Клас SSD1306 містить основні функції для керування дисплеєм, а підкласи реалізують специфічні методи для роботи з I2C та SPI інтерфейсами відповідно. Бібліотека налаштовує дисплей, керує буфером кадрів і дозволяє відправляти команди та дані на дисплей для його оновлення.
  Бібліотека hx711.py дозволяє взаємодіяти з аналогово-цифровим перетворювачем HX711, який використовується для зчитування даних з вагових датчиків. Вона забезпечує функції для ініціалізації датчика, зчитування даних, налаштування масштабування та калібрування (обнулення). Бібліотека також підтримує увімкнення та вимкнення живлення датчика.
  Бібліотека network була використана для реалізації Wi-Fi підключення.
  Бібліотеки urequests та json були імпортовані для успішного виконання http-запитів до сервера.
  Програмна частина пристрою складається з кодової частини для мікроконтролера ESP32, основна частина якої знаходиться у файлі main.py, з якого і починається виконання програми. Вже з нього відбувається взаємодія з іншими класами системи, запити до сервера, імпорт бібліотек тощо.

5 ПОБУДОВА ДІАГРАМИ ВЗАЄМОДІЇ
  
  Взаємодія пристроя з користувачем починається з його увімкнення та підключається до Wi-Fi. Якщо підключення успішне, пристрій отримує дані про контейнер та починає вимір його заповненості. Якщо вільного місця в контейнері більше ніж 50 см заввишки, відбувається реєстрація клієнта, зважування сміття, реєстрація цієї операції, потім повертається до визначення заповненості баку та очікування нових відходів. Якщо менше ніж на 50 см, пристрій відправляє звукове та текстове повідомлення про переповненість сміттям, формує заявку на вивіз сміття та очікує звільнення контейнеру від нього. Відповідно, доки місце в ньому не з’явиться, клієнти не матимуть змоги користуватися сервісом. Це дозволяє автоматизувати процес управління відходами.
Цей процес взаємодії дозволяє ефективно керувати збором та транспортуванням сміття за допомогою IoT пристрою.
  На основі описаної взаємодії пристрою з користувачем було побудовано діаграму взаємодії (див. рис. 3).

6 ПОБУДОВА ДІАГРАМИ ДІЯЛЬНОСТІ
     
  Діяльність системи можна описати як взаємодію пристрою і серверної частини. Робота пристрою починається з його увімкнення, потім відбувається під’єднання до Wi-Fi та отримання конфігураційних даних із сервера. Після цього виконується нескінченний цикл, у я кому кожну ітерацію визначається відстань від датчика до сміття, тим самим дізнається наповненість контейнеру. Отримана величина перевіряється на відповідність вимогам: у разі перевищенні дистанції у 300 см, загоряється зелений світлодіод та виводиться повідомлення на дисплеї про неповний бак; якщо менше 300 см, але більше 50 см, то горить жовтий діод та повідомляється про часткову наповненість; у разі ж наявності вільного простору менше ніж 50 см, контейнер блокується та здача сміття стає неможливою, загоряється червоний діод та з’являється попередження про заповненість баку. Кожна зміна заповненості фіксується і викликає оновлення даних на сервері щодо стану баку. Доки сміття не буде вивезено, контейнером неможливо буде скористатися. Якщо ж вільне місце є, то утриманням зеленої кнопки за наявності профілю клієнт реєструється для здачі сміття. Після успішної авторизації загоряється зелений діод, що означає дозвіл на проведення здачі сміття і пропонується його внесення. Коли весь необхідний обсяг відходів внесено, клієнт має натиснути червону кнопку, що  викликає  зважування, результат якого, а також нараховані бонуси за нього виводяться на екран. На сервер відправляється інформація про операцію.
  Спираючись на описану діяльність пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. додат. Б.1). 

ВИСНОВКИ

  Під час лабораторної роботи було отримані навички з проєктування IoT частини програмної системи. Результатом виконаної роботи є розроблена програмна реалізація IoT частини програмної системи з використанням ESP32. При розробці продукту було дотримано вимог до чистого коду мови програмування Python. 
